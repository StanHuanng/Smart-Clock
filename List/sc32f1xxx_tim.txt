; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\output\sc32f1xxx_tim.o --asm_dir=..\List\ --list_dir=..\List\ --depend=..\output\sc32f1xxx_tim.d --cpu=Cortex-M0+ --apcs=interwork --diag_suppress=9931 -I..\FWLib\SC32F1XXX_Lib\inc -I..\User\HeadFiles -I..\User -I..\Drivers -I..\Apps -I..\CMSIS -IC:\Keil_v5\ARM\PACK\Keil\SC32F1xxx_DFP\1.0.6\Device\SC32F10xx\FWLib\SC32_Lib\inc -D__UVISION_VERSION=539 -DSC32F10xx -DSC32f10xx --omf_browse=..\output\sc32f1xxx_tim.crf ..\FWLib\SC32F1XXX_Lib\src\sc32f1xxx_tim.c]
                          THUMB

                          AREA ||i.TIM_ClearFlag||, CODE, READONLY, ALIGN=1

                  TIM_ClearFlag PROC
;;;894     */
;;;895    void TIM_ClearFlag ( TIM_TypeDef* TIMx, uint16_t TIM_FLAG )
000000  60c1              STR      r1,[r0,#0xc]
;;;896    {
;;;897        /* Check the parameters */
;;;898        assert_param ( IS_TIM_ALL_PERIPH ( TIMx ) );
;;;899    
;;;900        /* Clear the flags */
;;;901        TIMx->TIM_STS = ( uint16_t ) TIM_FLAG;
;;;902    }
000002  4770              BX       lr
;;;903    
                          ENDP


                          AREA ||i.TIM_ClockOutputCmd||, CODE, READONLY, ALIGN=1

                  TIM_ClockOutputCmd PROC
;;;723     */
;;;724    void TIM_ClockOutputCmd ( TIM_TypeDef* TIMx, FunctionalState NewState )
000000  2201              MOVS     r2,#1
;;;725    {
;;;726        /* Check the parameters */
;;;727        assert_param ( IS_TIM_ALL_PERIPH ( TIMx ) );
;;;728        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;729    
;;;730        if ( NewState != DISABLE )
;;;731        {
;;;732            /* Enable the TIM Clock Output */
;;;733            TIMx->TIM_CON |= TIM_CON_TXOE;
000002  03d2              LSLS     r2,r2,#15
000004  2900              CMP      r1,#0                 ;730
;;;734        }
;;;735        else
;;;736        {
;;;737            /* Disable the TIM Clock Output */
;;;738            TIMx->TIM_CON &= ( uint32_t ) ~TIM_CON_TXOE;
000006  6801              LDR      r1,[r0,#0]
000008  d001              BEQ      |L2.14|
00000a  4311              ORRS     r1,r1,r2              ;733
00000c  e000              B        |L2.16|
                  |L2.14|
00000e  4391              BICS     r1,r1,r2
                  |L2.16|
000010  6001              STR      r1,[r0,#0]            ;733
;;;739        }
;;;740    }
000012  4770              BX       lr
;;;741    
                          ENDP


                          AREA ||i.TIM_Cmd||, CODE, READONLY, ALIGN=2

                  TIM_Cmd PROC
;;;173     */
;;;174    void TIM_Cmd ( TIM_TypeDef* TIMx, FunctionalState NewState )
000000  2900              CMP      r1,#0
;;;175    {
;;;176        /* Check the parameters */
;;;177        assert_param ( IS_TIM_ALL_PERIPH ( TIMx ) );
;;;178        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;179    
;;;180        if ( NewState != DISABLE )
;;;181        {
;;;182            /* Enable the TIM Counter */
;;;183            TIMx->TIM_CON |= TIM_CON_TR;
;;;184        }
;;;185        else
;;;186        {
;;;187            /* Disable the TIM Counter */
;;;188            TIMx->TIM_CON &= ( uint16_t ) ~TIM_CON_TR;
000002  6801              LDR      r1,[r0,#0]
000004  d002              BEQ      |L3.12|
000006  2280              MOVS     r2,#0x80              ;183
000008  4311              ORRS     r1,r1,r2              ;183
00000a  e001              B        |L3.16|
                  |L3.12|
00000c  4a01              LDR      r2,|L3.20|
00000e  4011              ANDS     r1,r1,r2
                  |L3.16|
000010  6001              STR      r1,[r0,#0]            ;183
;;;189        }
;;;190    }
000012  4770              BX       lr
;;;191    
                          ENDP

                  |L3.20|
                          DCD      0x0000ff7f

                          AREA ||i.TIM_DMACmd||, CODE, READONLY, ALIGN=1

                  TIM_DMACmd PROC
;;;923     */
;;;924    void TIM_DMACmd ( TIM_TypeDef* TIMx, uint16_t TIM_DMAReq, FunctionalState NewState )
000000  2a00              CMP      r2,#0
;;;925    {
;;;926        /* Check the parameters */
;;;927        assert_param ( IS_TIM_DMA_PERIPH ( TIMx ) );
;;;928        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;929    
;;;930        if ( NewState != DISABLE )
;;;931        {
;;;932            /* Enable the TIM DMA */
;;;933            TIMx->TIM_IDE |= TIM_DMAReq;
;;;934        }
;;;935        else
;;;936        {
;;;937            /* Disable the TIM DMA */
;;;938            TIMx->TIM_IDE &= ( uint16_t ) ~TIM_DMAReq;
000002  6982              LDR      r2,[r0,#0x18]
000004  d001              BEQ      |L4.10|
000006  430a              ORRS     r2,r2,r1              ;933
000008  e002              B        |L4.16|
                  |L4.10|
00000a  43c9              MVNS     r1,r1
00000c  b289              UXTH     r1,r1
00000e  400a              ANDS     r2,r2,r1
                  |L4.16|
000010  6182              STR      r2,[r0,#0x18]         ;933
;;;939        }
;;;940    }
000012  4770              BX       lr
;;;941    
                          ENDP


                          AREA ||i.TIM_DeInit||, CODE, READONLY, ALIGN=2

                  TIM_DeInit PROC
;;;52      */
;;;53     void TIM_DeInit ( TIM_TypeDef* TIMx )
000000  492d              LDR      r1,|L5.184|
;;;54     {
000002  b510              PUSH     {r4,lr}
;;;55         assert_param ( IS_TIM_ALL_PERIPH ( TIMx ) );
;;;56     
;;;57         if ( TIMx == TIM0 )
000004  4288              CMP      r0,r1
000006  d106              BNE      |L5.22|
;;;58         {
;;;59             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_TIM0, ENABLE );
000008  2101              MOVS     r1,#1
00000a  4608              MOV      r0,r1
00000c  f7fffffe          BL       RCC_APB0PeriphResetCmd
;;;60             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_TIM0, DISABLE );
000010  2100              MOVS     r1,#0
000012  2001              MOVS     r0,#1
000014  e009              B        |L5.42|
                  |L5.22|
;;;61         }
;;;62         else if ( TIMx == TIM1 )
000016  4928              LDR      r1,|L5.184|
000018  3140              ADDS     r1,r1,#0x40
00001a  4288              CMP      r0,r1
00001c  d108              BNE      |L5.48|
;;;63         {
;;;64             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_TIM1, ENABLE );
00001e  2101              MOVS     r1,#1
000020  2002              MOVS     r0,#2
000022  f7fffffe          BL       RCC_APB0PeriphResetCmd
;;;65             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_TIM1, DISABLE );
000026  2100              MOVS     r1,#0
000028  2002              MOVS     r0,#2
                  |L5.42|
00002a  f7fffffe          BL       RCC_APB0PeriphResetCmd
;;;66         }
;;;67         else if ( TIMx == TIM2 )
;;;68         {
;;;69             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_TIM2, ENABLE );
;;;70             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_TIM2, DISABLE );
;;;71         }
;;;72         else if ( TIMx == TIM3 )
;;;73         {
;;;74             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_TIM3, ENABLE );
;;;75             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_TIM3, DISABLE );
;;;76         }
;;;77         else if ( TIMx == TIM4 )
;;;78         {
;;;79             RCC_APB1PeriphResetCmd ( RCC_APB1Periph_TIM4, ENABLE );
;;;80             RCC_APB1PeriphResetCmd ( RCC_APB1Periph_TIM4, DISABLE );
;;;81         }
;;;82         else if ( TIMx == TIM5 )
;;;83         {
;;;84             RCC_APB1PeriphResetCmd ( RCC_APB1Periph_TIM5, ENABLE );
;;;85             RCC_APB1PeriphResetCmd ( RCC_APB1Periph_TIM5, DISABLE );
;;;86         }
;;;87         else if ( TIMx == TIM6 )
;;;88         {
;;;89             RCC_APB1PeriphResetCmd ( RCC_APB1Periph_TIM6, ENABLE );
;;;90             RCC_APB1PeriphResetCmd ( RCC_APB1Periph_TIM6, DISABLE );
;;;91         }
;;;92         else if ( TIMx == TIM7 )
;;;93         {
;;;94             RCC_APB1PeriphResetCmd ( RCC_APB1Periph_TIM7, ENABLE );
;;;95             RCC_APB1PeriphResetCmd ( RCC_APB1Periph_TIM7, DISABLE );
;;;96         }
;;;97     }
00002e  bd10              POP      {r4,pc}
                  |L5.48|
000030  4921              LDR      r1,|L5.184|
000032  3180              ADDS     r1,r1,#0x80           ;67
000034  4288              CMP      r0,r1                 ;67
000036  d106              BNE      |L5.70|
000038  2101              MOVS     r1,#1                 ;69
00003a  2004              MOVS     r0,#4                 ;69
00003c  f7fffffe          BL       RCC_APB0PeriphResetCmd
000040  2100              MOVS     r1,#0                 ;70
000042  2004              MOVS     r0,#4                 ;70
000044  e7f1              B        |L5.42|
                  |L5.70|
000046  491c              LDR      r1,|L5.184|
000048  31c0              ADDS     r1,r1,#0xc0           ;72
00004a  4288              CMP      r0,r1                 ;72
00004c  d106              BNE      |L5.92|
00004e  2101              MOVS     r1,#1                 ;74
000050  2008              MOVS     r0,#8                 ;74
000052  f7fffffe          BL       RCC_APB0PeriphResetCmd
000056  2100              MOVS     r1,#0                 ;75
000058  2008              MOVS     r0,#8                 ;75
00005a  e7e6              B        |L5.42|
                  |L5.92|
00005c  4917              LDR      r1,|L5.188|
00005e  4288              CMP      r0,r1                 ;77
000060  d106              BNE      |L5.112|
000062  2101              MOVS     r1,#1                 ;79
000064  4608              MOV      r0,r1                 ;79
000066  f7fffffe          BL       RCC_APB1PeriphResetCmd
00006a  2100              MOVS     r1,#0                 ;80
00006c  2001              MOVS     r0,#1                 ;80
00006e  e009              B        |L5.132|
                  |L5.112|
000070  4912              LDR      r1,|L5.188|
000072  3140              ADDS     r1,r1,#0x40           ;82
000074  4288              CMP      r0,r1                 ;82
000076  d108              BNE      |L5.138|
000078  2101              MOVS     r1,#1                 ;84
00007a  2002              MOVS     r0,#2                 ;84
00007c  f7fffffe          BL       RCC_APB1PeriphResetCmd
000080  2100              MOVS     r1,#0                 ;85
000082  2002              MOVS     r0,#2                 ;85
                  |L5.132|
000084  f7fffffe          BL       RCC_APB1PeriphResetCmd
                  |L5.136|
000088  bd10              POP      {r4,pc}
                  |L5.138|
00008a  490c              LDR      r1,|L5.188|
00008c  3180              ADDS     r1,r1,#0x80           ;87
00008e  4288              CMP      r0,r1                 ;87
000090  d106              BNE      |L5.160|
000092  2101              MOVS     r1,#1                 ;89
000094  2004              MOVS     r0,#4                 ;89
000096  f7fffffe          BL       RCC_APB1PeriphResetCmd
00009a  2100              MOVS     r1,#0                 ;90
00009c  2004              MOVS     r0,#4                 ;90
00009e  e7f1              B        |L5.132|
                  |L5.160|
0000a0  4906              LDR      r1,|L5.188|
0000a2  31c0              ADDS     r1,r1,#0xc0           ;92
0000a4  4288              CMP      r0,r1                 ;92
0000a6  d1ef              BNE      |L5.136|
0000a8  2101              MOVS     r1,#1                 ;94
0000aa  2008              MOVS     r0,#8                 ;94
0000ac  f7fffffe          BL       RCC_APB1PeriphResetCmd
0000b0  2100              MOVS     r1,#0                 ;95
0000b2  2008              MOVS     r0,#8                 ;95
0000b4  e7e6              B        |L5.132|
;;;98     
                          ENDP

0000b6  0000              DCW      0x0000
                  |L5.184|
                          DCD      0x40020100
                  |L5.188|
                          DCD      0x40021100

                          AREA ||i.TIM_GetAutoreload||, CODE, READONLY, ALIGN=1

                  TIM_GetAutoreload PROC
;;;272     */
;;;273    uint16_t TIM_GetAutoreload ( TIM_TypeDef* TIMx )
000000  6880              LDR      r0,[r0,#8]
;;;274    {
;;;275        /* Check the parameters */
;;;276        assert_param ( IS_TIM_ALL_PERIPH ( TIMx ) );
;;;277    
;;;278        /* Get the ReloadData Register value */
;;;279        return TIMx->TIM_RLD;
000002  b280              UXTH     r0,r0
;;;280    }
000004  4770              BX       lr
;;;281    
                          ENDP


                          AREA ||i.TIM_GetCounter||, CODE, READONLY, ALIGN=1

                  TIM_GetCounter PROC
;;;227     */
;;;228    uint32_t TIM_GetCounter ( TIM_TypeDef* TIMx )
000000  6840              LDR      r0,[r0,#4]
;;;229    {
;;;230        /* Check the parameters */
;;;231        assert_param ( IS_TIM_ALL_PERIPH ( TIMx ) );
;;;232    
;;;233        /* Get the Counter Register value */
;;;234        return TIMx->TIM_CNT;
;;;235    }
000002  4770              BX       lr
;;;236    
                          ENDP


                          AREA ||i.TIM_GetFailingCapture||, CODE, READONLY, ALIGN=1

                  TIM_GetFailingCapture PROC
;;;502      */
;;;503    uint32_t TIM_GetFailingCapture ( TIM_TypeDef* TIMx )
000000  6940              LDR      r0,[r0,#0x14]
;;;504    {
;;;505        /* Check the parameters */
;;;506        assert_param ( IS_TIM_ALL_PERIPH ( TIMx ) );
;;;507    
;;;508        /* Get the Failing Capture Register value */
;;;509        return TIMx->TIM_PDTB_FCAP;
;;;510    }
000002  4770              BX       lr
;;;511    
                          ENDP


                          AREA ||i.TIM_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  TIM_GetFlagStatus PROC
;;;859     */
;;;860    FlagStatus TIM_GetFlagStatus ( TIM_TypeDef* TIMx, TIM_Flag_TypeDef TIM_FLAG )
000000  4602              MOV      r2,r0
;;;861    {
;;;862        FlagStatus bitstatus = RESET;
;;;863        /* Check the parameters */
;;;864        assert_param ( IS_TIM_ALL_PERIPH ( TIMx ) );
;;;865        assert_param ( IS_GET_TIM_FLAG ( TIM_FLAG ) );
;;;866    
;;;867        if ( ( TIMx->TIM_STS & TIM_FLAG ) != ( uint16_t ) RESET )
000002  68d2              LDR      r2,[r2,#0xc]
000004  2000              MOVS     r0,#0                 ;862
000006  420a              TST      r2,r1
000008  d000              BEQ      |L9.12|
;;;868        {
;;;869            bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L9.12|
;;;870        }
;;;871        else
;;;872        {
;;;873            bitstatus = RESET;
;;;874        }
;;;875        return bitstatus;
;;;876    }
00000c  4770              BX       lr
;;;877    
                          ENDP


                          AREA ||i.TIM_GetPrescaler||, CODE, READONLY, ALIGN=1

                  TIM_GetPrescaler PROC
;;;338     */
;;;339    TIM_Prescaler_TypeDef TIM_GetPrescaler ( TIM_TypeDef* TIMx )
000000  6800              LDR      r0,[r0,#0]
;;;340    {
;;;341        /* Check the parameters */
;;;342        assert_param ( IS_TIM_ALL_PERIPH ( TIMx ) );
;;;343    
;;;344        /* Get the CKD value */
;;;345        return ( TIM_Prescaler_TypeDef ) ( TIMx->TIM_CON & TIM_CON_TIMCLK );
000002  2107              MOVS     r1,#7
000004  0209              LSLS     r1,r1,#8
000006  4008              ANDS     r0,r0,r1
;;;346    }
000008  4770              BX       lr
;;;347    
                          ENDP


                          AREA ||i.TIM_GetRisingCapture||, CODE, READONLY, ALIGN=1

                  TIM_GetRisingCapture PROC
;;;480      */
;;;481    uint32_t TIM_GetRisingCapture ( TIM_TypeDef* TIMx )
000000  6900              LDR      r0,[r0,#0x10]
;;;482    {
;;;483        /* Check the parameters */
;;;484        assert_param ( IS_TIM_ALL_PERIPH ( TIMx ) );
;;;485    
;;;486        /* Get the Rising Capture Register value */
;;;487        return TIMx->TIM_PDTA_RCAP;
;;;488    }
000002  4770              BX       lr
;;;489    
                          ENDP


                          AREA ||i.TIM_ICCmd||, CODE, READONLY, ALIGN=2

                  TIM_ICCmd PROC
;;;449     */
;;;450    void TIM_ICCmd ( TIM_TypeDef* TIMx, FunctionalState NewState )
000000  2900              CMP      r1,#0
;;;451    {
;;;452        /* Check the parameters */
;;;453        assert_param ( IS_TIM_ALL_PERIPH ( TIMx ) );
;;;454        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;455    
;;;456        if ( NewState != DISABLE )
;;;457        {
;;;458            /* Enable the capture function of TIMx */
;;;459            TIMx->TIM_CON |= TIM_CON_CPRL;
;;;460        }
;;;461        else
;;;462        {
;;;463            /* Disable the capture function of TIMx */
;;;464            TIMx->TIM_CON &= ( uint16_t ) ~TIM_CON_CPRL;
000002  6801              LDR      r1,[r0,#0]
000004  d002              BEQ      |L12.12|
000006  2201              MOVS     r2,#1                 ;459
000008  4311              ORRS     r1,r1,r2              ;459
00000a  e001              B        |L12.16|
                  |L12.12|
00000c  4a01              LDR      r2,|L12.20|
00000e  4011              ANDS     r1,r1,r2
                  |L12.16|
000010  6001              STR      r1,[r0,#0]            ;459
;;;465        }
;;;466    }
000012  4770              BX       lr
;;;467    
                          ENDP

                  |L12.20|
                          DCD      0x0000fffe

                          AREA ||i.TIM_ICInit||, CODE, READONLY, ALIGN=2

                  TIM_ICInit PROC
;;;376     */
;;;377    void TIM_ICInit ( TIM_TypeDef* TIMx, TIM_IC_InitTypeDef* TIM_IC_InitStruct )
000000  b510              PUSH     {r4,lr}
;;;378    {
;;;379        uint16_t tmpreg;
;;;380        /* Check the parameters */
;;;381    
;;;382    #if defined(SC32f10xx) || defined(SC32f12xx)
;;;383        if ( TIM_IC_InitStruct->TIM_FICPIN == TIM_FICPin_TnEx )
000002  884b              LDRH     r3,[r1,#2]
;;;384            assert_param ( IS_TIM_TNEX_PERIPH ( TIMx ) );
;;;385        if ( ( TIM_IC_InitStruct->TIM_FICPIN == TIM_FICPin_Tn ) ||
;;;386                ( TIM_IC_InitStruct->TIM_RICPIN == TIM_RICPin_Tn ) )
;;;387            assert_param ( IS_TIM_TN_PERIPH ( TIMx ) );
;;;388    #elif defined(SC32f11xx)
;;;389        assert_param ( IS_TIM_ALL_PERIPH ( TIMx ) );
;;;390    #endif
;;;391    
;;;392    
;;;393        /* Get the TIMx TIM_CON register value */
;;;394        tmpreg = ( uint16_t ) TIMx->TIM_CON;
000004  6802              LDR      r2,[r0,#0]
;;;395    
;;;396        /* Clear EXENR, EXENF and EXENX SPR bits */
;;;397        tmpreg &= ~ ( TIM_CON_EXENR | TIM_CON_EXENF | TIM_CON_FSEL | TIM_CON_EXENX );
000006  243c              MOVS     r4,#0x3c
000008  b292              UXTH     r2,r2                 ;394
00000a  43a2              BICS     r2,r2,r4
;;;398    
;;;399    
;;;400    #if defined(SC32f10xx)
;;;401        if ( TIMx == TIM0 )
00000c  4c05              LDR      r4,|L13.36|
00000e  42a0              CMP      r0,r4
000010  d104              BNE      |L13.28|
;;;402        {
;;;403            if ( TIM_IC_InitStruct->TIM_FICPIN != TIM_FICPin_Tn )
000012  2b08              CMP      r3,#8
000014  d000              BEQ      |L13.24|
                  |L13.22|
;;;404            {
;;;405                tmpreg |= TIM_IC_InitStruct->TIM_FICPIN;
000016  431a              ORRS     r2,r2,r3
                  |L13.24|
;;;406            }
;;;407    
;;;408        }
;;;409        else
;;;410        {
;;;411            tmpreg |= ( TIM_IC_InitStruct->TIM_FICPIN | TIM_IC_InitStruct->TIM_RICPIN );
;;;412        }
;;;413    #elif defined(SC32f11xx) || defined(SC32f12xx)
;;;414    
;;;415        tmpreg |= ( TIM_IC_InitStruct->TIM_FICPIN | TIM_IC_InitStruct->TIM_RICPIN );
;;;416    #endif
;;;417    
;;;418    
;;;419        TIMx->TIM_CON = ( uint32_t ) tmpreg;
000018  6002              STR      r2,[r0,#0]
;;;420    }
00001a  bd10              POP      {r4,pc}
                  |L13.28|
00001c  8809              LDRH     r1,[r1,#0]            ;411
00001e  430b              ORRS     r3,r3,r1              ;411
000020  e7f9              B        |L13.22|
;;;421    
                          ENDP

000022  0000              DCW      0x0000
                  |L13.36|
                          DCD      0x40020100

                          AREA ||i.TIM_ICStructInit||, CODE, READONLY, ALIGN=1

                  TIM_ICStructInit PROC
;;;426      */
;;;427    void TIM_ICStructInit ( TIM_IC_InitTypeDef* TIM_IC_InitStruct )
000000  2100              MOVS     r1,#0
;;;428    {
;;;429        /* Set the default configuration */
;;;430        TIM_IC_InitStruct->TIM_FICPIN = TIM_FICPin_Disable;
000002  8041              STRH     r1,[r0,#2]
;;;431        TIM_IC_InitStruct->TIM_RICPIN = TIM_RICPin_Disable;
000004  8001              STRH     r1,[r0,#0]
;;;432    }
000006  4770              BX       lr
;;;433    
                          ENDP


                          AREA ||i.TIM_ITConfig||, CODE, READONLY, ALIGN=1

                  TIM_ITConfig PROC
;;;821     */
;;;822    void TIM_ITConfig ( TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState )
000000  2a00              CMP      r2,#0
;;;823    {
;;;824        /* Check the parameters */
;;;825        assert_param ( IS_TIM_ALL_PERIPH ( TIMx ) );
;;;826        assert_param ( IS_TIM_IT ( TIM_IT ) );
;;;827        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;828    
;;;829        if ( NewState != DISABLE )
;;;830        {
;;;831            /* Enable the Interrupt sources */
;;;832            TIMx->TIM_IDE |= TIM_IT;
;;;833        }
;;;834        else
;;;835        {
;;;836            /* Disable the Interrupt sources */
;;;837            TIMx->TIM_IDE &= ( uint16_t ) ~TIM_IT;
000002  6982              LDR      r2,[r0,#0x18]
000004  d001              BEQ      |L15.10|
000006  430a              ORRS     r2,r2,r1              ;832
000008  e002              B        |L15.16|
                  |L15.10|
00000a  43c9              MVNS     r1,r1
00000c  b289              UXTH     r1,r1
00000e  400a              ANDS     r2,r2,r1
                  |L15.16|
000010  6182              STR      r2,[r0,#0x18]         ;832
;;;838        }
;;;839    }
000012  4770              BX       lr
;;;840    
                          ENDP


                          AREA ||i.TIM_PWMGetDuty||, CODE, READONLY, ALIGN=1

                  TIM_PWMGetDuty PROC
;;;671     */
;;;672    uint16_t TIM_PWMGetDuty ( TIM_TypeDef* TIMx, TIM_PWMChannel_Typedef TIM_PWMChannel )
000000  2902              CMP      r1,#2
;;;673    {
000002  d002              BEQ      |L16.10|
;;;674        uint16_t tmpduty = 0;
;;;675    
;;;676        /* Check the parameters */
;;;677        assert_param ( IS_TIM_ALL_PERIPH ( TIMx ) );
;;;678    
;;;679        if ( TIM_PWMChannel == TIM_PWMChannel_PWMA )
;;;680        {
;;;681            tmpduty = ( uint16_t ) TIMx->TIM_PDTA_RCAP;
;;;682        }
;;;683        else
;;;684        {
;;;685            tmpduty = ( uint16_t ) TIMx->TIM_PDTB_FCAP;
000004  6940              LDR      r0,[r0,#0x14]
                  |L16.6|
000006  b280              UXTH     r0,r0                 ;681
;;;686        }
;;;687    
;;;688        return tmpduty;
;;;689    }
000008  4770              BX       lr
                  |L16.10|
00000a  6900              LDR      r0,[r0,#0x10]         ;681
00000c  e7fb              B        |L16.6|
;;;690    
                          ENDP


                          AREA ||i.TIM_PWMInit||, CODE, READONLY, ALIGN=2

                  TIM_PWMInit PROC
;;;541     */
;;;542    void TIM_PWMInit ( TIM_TypeDef* TIMx, TIM_PWM_InitTypeDef* TIM_PWM_InitStruct )
000000  b510              PUSH     {r4,lr}
;;;543    {
;;;544        uint32_t tmpreg;
;;;545        /* Check the parameters */
;;;546    #if defined(SC32f10xx) || defined(SC32f12xx)
;;;547        if ( ( TIM_PWM_InitStruct->TIM_PWMLowPolarityChannl == TIM_PWMChannel_PWMA ) ||
000002  884a              LDRH     r2,[r1,#2]
;;;548                ( TIM_PWM_InitStruct->TIM_PWMOutputChannl == TIM_PWMChannel_PWMA ) )
000004  880b              LDRH     r3,[r1,#0]
;;;549            assert_param ( IS_TIM_TN_PERIPH ( TIMx ) );
;;;550        if ( ( TIM_PWM_InitStruct->TIM_PWMLowPolarityChannl == TIM_PWMChannel_PWMB ) ||
;;;551                ( TIM_PWM_InitStruct->TIM_PWMOutputChannl == TIM_PWMChannel_PWMB ) )
;;;552            assert_param ( IS_TIM_TNEX_PERIPH ( TIMx ) );
;;;553    #elif defined(SC32f11xx)
;;;554        assert_param ( IS_TIM_ALL_PERIPH ( TIMx ) );
;;;555    #endif
;;;556        /* Get the TIMx TIM_CON value */
;;;557        tmpreg = TIMx->TIM_CON;
000006  6801              LDR      r1,[r0,#0]
;;;558    
;;;559        /* Clear EPWMNA,EPWMNB,INVNA and INVNB bit */
;;;560        tmpreg &= ( uint32_t ) ~ ( TIM_CON_EPWMNA | TIM_CON_EPWMNB | TIM_CON_INVNA | TIM_CON_INVNB );
000008  240f              MOVS     r4,#0xf
00000a  02e4              LSLS     r4,r4,#11
00000c  43a1              BICS     r1,r1,r4
;;;561    
;;;562        /* TIM0 has no TnPWMA and TIM1,2,3,4,5,6,7 has no TnPWMB */
;;;563    #if defined(SC32f10xx)
;;;564        /* TIM0 has no TnPWMA and TIM1,2,3,4,5,6,7 has no TnPWMB */
;;;565        if ( ( ( TIMx == TIM0 ) && ( TIM_PWM_InitStruct->TIM_PWMOutputChannl != TIM_PWMChannel_PWMA ) &&
00000e  4c09              LDR      r4,|L17.52|
000010  42a0              CMP      r0,r4
000012  d103              BNE      |L17.28|
000014  2b02              CMP      r3,#2
000016  d001              BEQ      |L17.28|
;;;566                ( TIM_PWM_InitStruct->TIM_PWMLowPolarityChannl != TIM_PWMChannel_PWMA ) ) ||
000018  2a02              CMP      r2,#2
00001a  d105              BNE      |L17.40|
                  |L17.28|
;;;567                ( ( TIMx != TIM0 ) && ( TIM_PWM_InitStruct->TIM_PWMOutputChannl != TIM_PWMChannel_PWMB ) &&
00001c  42a0              CMP      r0,r4
00001e  d007              BEQ      |L17.48|
000020  2b01              CMP      r3,#1
000022  d005              BEQ      |L17.48|
;;;568                  ( TIM_PWM_InitStruct->TIM_PWMLowPolarityChannl != TIM_PWMChannel_PWMB ) ) )
000024  2a01              CMP      r2,#1
000026  d003              BEQ      |L17.48|
                  |L17.40|
;;;569        {
;;;570            /* Set EPWMNA and EPWMNB bit to PWM Output Channl value */
;;;571            /* Set INVNA and INVNB bit to PWM Low Polarity Channl value */
;;;572            tmpreg |= ( uint32_t ) ( ( TIM_PWM_InitStruct->TIM_PWMOutputChannl << ( 13U ) )
000028  035b              LSLS     r3,r3,#13
00002a  02d2              LSLS     r2,r2,#11
00002c  4313              ORRS     r3,r3,r2
00002e  4319              ORRS     r1,r1,r3
                  |L17.48|
;;;573                                     | ( TIM_PWM_InitStruct->TIM_PWMLowPolarityChannl ) << ( 11U ) );
;;;574        }
;;;575    #elif defined(SC32f11xx)|| defined(SC32f12xx)
;;;576        {
;;;577            /* Set EPWMNA and EPWMNB bit to PWM Output Channl value */
;;;578            /* Set INVNA and INVNB bit to PWM Low Polarity Channl value */
;;;579            tmpreg |= ( uint32_t ) ( ( TIM_PWM_InitStruct->TIM_PWMOutputChannl << ( 13U ) )
;;;580                                     | ( TIM_PWM_InitStruct->TIM_PWMLowPolarityChannl ) << ( 11U ) );
;;;581        }
;;;582    
;;;583    #endif
;;;584    
;;;585        /* Write to TIMx TIM_CON */
;;;586        TIMx->TIM_CON = tmpreg;
000030  6001              STR      r1,[r0,#0]
;;;587    }
000032  bd10              POP      {r4,pc}
;;;588    
                          ENDP

                  |L17.52|
                          DCD      0x40020100

                          AREA ||i.TIM_PWMSetDuty||, CODE, READONLY, ALIGN=2

                  TIM_PWMSetDuty PROC
;;;618     */
;;;619    void TIM_PWMSetDuty ( TIM_TypeDef* TIMx, TIM_PWMChannel_Typedef TIM_PWMChannel, uint16_t PWM_DutyValue )
000000  4b06              LDR      r3,|L18.28|
;;;620    {
;;;621    #if defined(SC32f10xx)
;;;622        /* Check the parameters */
;;;623        if ( TIM_PWMChannel == TIM_PWMChannel_PWMA )
;;;624            assert_param ( IS_TIM_TN_PERIPH ( TIMx ) );
;;;625        if ( TIM_PWMChannel == TIM_PWMChannel_PWMB )
;;;626            assert_param ( IS_TIM_TNEX_PERIPH ( TIMx ) );
;;;627    
;;;628        /* TIM0 has no TnPWMA */
;;;629        if ( ( TIMx != TIM0 ) && ( TIM_PWMChannel == TIM_PWMChannel_PWMA ) )
000002  4298              CMP      r0,r3
000004  d001              BEQ      |L18.10|
000006  2902              CMP      r1,#2
000008  d005              BEQ      |L18.22|
                  |L18.10|
;;;630        {
;;;631            TIMx->TIM_PDTA_RCAP = PWM_DutyValue;
;;;632        }
;;;633        /* TIM1,2,3,4,5,6,7 has no TnPWMB */
;;;634        else if ( ( TIMx == TIM0 ) && ( TIM_PWMChannel == TIM_PWMChannel_PWMB ) )
00000a  4298              CMP      r0,r3
00000c  d102              BNE      |L18.20|
00000e  2901              CMP      r1,#1
000010  d100              BNE      |L18.20|
;;;635        {
;;;636            TIMx->TIM_PDTB_FCAP = PWM_DutyValue;
000012  6142              STR      r2,[r0,#0x14]
                  |L18.20|
;;;637        }
;;;638    #elif defined(SC32f11xx)|| defined(SC32f12xx)
;;;639        assert_param ( IS_TIM_ALL_PERIPH ( TIMx ) );
;;;640    
;;;641        if ( TIM_PWMChannel == TIM_PWMChannel_PWMA )
;;;642        {
;;;643            TIMx->TIM_PDTA_RCAP = PWM_DutyValue;
;;;644        }
;;;645        else if ( TIM_PWMChannel == TIM_PWMChannel_PWMB )
;;;646        {
;;;647            TIMx->TIM_PDTB_FCAP = PWM_DutyValue;
;;;648        }
;;;649    
;;;650    #endif
;;;651    
;;;652    
;;;653    }
000014  4770              BX       lr
                  |L18.22|
000016  6102              STR      r2,[r0,#0x10]         ;631
000018  4770              BX       lr
;;;654    
                          ENDP

00001a  0000              DCW      0x0000
                  |L18.28|
                          DCD      0x40020100

                          AREA ||i.TIM_PWMStructInit||, CODE, READONLY, ALIGN=1

                  TIM_PWMStructInit PROC
;;;593      */
;;;594    void TIM_PWMStructInit ( TIM_PWM_InitTypeDef* TIM_PWM_InitStruct )
000000  2100              MOVS     r1,#0
;;;595    {
;;;596        /* Set the default configuration */
;;;597        TIM_PWM_InitStruct->TIM_PWMLowPolarityChannl = TIM_PWMChannel_Less;
000002  8041              STRH     r1,[r0,#2]
;;;598        TIM_PWM_InitStruct->TIM_PWMOutputChannl = TIM_PWMChannel_Less;
000004  8001              STRH     r1,[r0,#0]
;;;599    }
000006  4770              BX       lr
;;;600    
                          ENDP


                          AREA ||i.TIM_PinRemapConfig||, CODE, READONLY, ALIGN=1

                  TIM_PinRemapConfig PROC
;;;768    #if defined(SC32f10xx) || defined(SC32f11xx)
;;;769    void TIM_PinRemapConfig ( TIM_TypeDef* TIMx, TIM_PinRemap_TypeDef TIM_Remap )
000000  6802              LDR      r2,[r0,#0]
;;;770    {
;;;771        uint32_t tmpreg ;
;;;772        /* Check the parameters */
;;;773        assert_param ( IS_TIM_REMAP_PERIPH ( TIMx ) );
;;;774        assert_param ( IS_TIM_PINREMAP ( TIM_Remap ) );
;;;775    
;;;776        tmpreg = TIMx->TIM_CON;
;;;777    
;;;778        tmpreg &= ( uint32_t ) ( ~TIM_CON_SPOS );
000002  2301              MOVS     r3,#1
000004  04db              LSLS     r3,r3,#19
000006  439a              BICS     r2,r2,r3
;;;779    
;;;780        tmpreg |= TIM_Remap;
000008  430a              ORRS     r2,r2,r1
;;;781    
;;;782        TIMx->TIM_CON = tmpreg;
00000a  6002              STR      r2,[r0,#0]
;;;783    }
00000c  4770              BX       lr
;;;784    #endif
                          ENDP


                          AREA ||i.TIM_SetAutoreload||, CODE, READONLY, ALIGN=1

                  TIM_SetAutoreload PROC
;;;250     */
;;;251    void TIM_SetAutoreload ( TIM_TypeDef* TIMx, uint16_t Autoreload )
000000  6081              STR      r1,[r0,#8]
;;;252    {
;;;253        /* Check the parameters */
;;;254        assert_param ( IS_TIM_ALL_PERIPH ( TIMx ) );
;;;255    
;;;256        /* Set the ReloadData Register value */
;;;257        TIMx->TIM_RLD = Autoreload;
;;;258    }
000002  4770              BX       lr
;;;259    
                          ENDP


                          AREA ||i.TIM_SetCounter||, CODE, READONLY, ALIGN=1

                  TIM_SetCounter PROC
;;;205     */
;;;206    void TIM_SetCounter ( TIM_TypeDef* TIMx, uint32_t Counter )
000000  6041              STR      r1,[r0,#4]
;;;207    {
;;;208        /* Check the parameters */
;;;209        assert_param ( IS_TIM_ALL_PERIPH ( TIMx ) );
;;;210    
;;;211        /* Set the Counter Register value */
;;;212        TIMx->TIM_CNT = ( uint32_t ) Counter;
;;;213    }
000002  4770              BX       lr
;;;214    
                          ENDP


                          AREA ||i.TIM_SetPerscaler||, CODE, READONLY, ALIGN=1

                  TIM_SetPerscaler PROC
;;;303     */
;;;304    void TIM_SetPerscaler ( TIM_TypeDef* TIMx, TIM_Prescaler_TypeDef TIM_Perscaler )
000000  6802              LDR      r2,[r0,#0]
;;;305    {
;;;306    
;;;307        /* Check the parameters */
;;;308        assert_param ( IS_TIM_ALL_PERIPH ( TIMx ) );
;;;309        assert_param ( IS_TIM_PRESCALER ( TIM_Perscaler ) );
;;;310    
;;;311        /* Reset the CKD Bits */
;;;312        TIMx->TIM_CON &= ( uint32_t ) ( ~TIM_CON_TIMCLK );
000002  2307              MOVS     r3,#7
000004  021b              LSLS     r3,r3,#8
000006  439a              BICS     r2,r2,r3
000008  6002              STR      r2,[r0,#0]
;;;313    
;;;314        /* Set the CKD value */
;;;315        TIMx->TIM_CON |= TIM_Perscaler;
00000a  6802              LDR      r2,[r0,#0]
00000c  430a              ORRS     r2,r2,r1
00000e  6002              STR      r2,[r0,#0]
;;;316    }
000010  4770              BX       lr
;;;317    
                          ENDP


                          AREA ||i.TIM_TIMBaseInit||, CODE, READONLY, ALIGN=2

                  TIM_TIMBaseInit PROC
;;;113     */
;;;114    void TIM_TIMBaseInit ( TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct )
000000  b530              PUSH     {r4,r5,lr}
;;;115    {
;;;116        /* Check the parameters */
;;;117        uint32_t tmpreg;
;;;118        assert_param ( IS_TIM_ALL_PERIPH ( TIMx ) );
;;;119        assert_param ( IS_TIM_PRESCALER ( TIM_TimeBaseInitStruct->TIM_EXENX ) );
;;;120        assert_param ( IS_TIM_WORKMODE ( TIM_TimeBaseInitStruct->TIM_WorkMode ) );
;;;121        assert_param ( IS_TIM_COUNTERMODE ( TIM_TimeBaseInitStruct->TIM_CounterMode ) );
;;;122        assert_param ( IS_TIM_RICPin ( TIM_TimeBaseInitStruct->TIM_Prescaler ) );
;;;123    
;;;124        /*---------------------------- TIMx TIM_CON Configuration ------------------------*/
;;;125        /* Get the TIMx TIM_CON value */
;;;126        tmpreg = TIMx->TIM_CON;
000002  6803              LDR      r3,[r0,#0]
;;;127        /* Clear TIMCK, DEC, CTSEL and EXENX SPR bits */
;;;128        tmpreg &= ( uint32_t ) ~ ( TIM_CON_TIMCLK | TIM_CON_CTSEL | TIM_CON_DEC | TIM_CON_EXENX );
000004  4a07              LDR      r2,|L24.36|
;;;129        /* Configure TIMx: Prescaler, AlignedMode and WorkMode */
;;;130        /* Set TIMCK bits according to Prescaler value */
;;;131        /* Set DEC bit according to CounterMode value */
;;;132        /* Set CTSEL bit according to WorkMode value */
;;;133        /* Set EXENX bit according to EXENX value */
;;;134        tmpreg |= ( uint32_t ) ( TIM_TimeBaseInitStruct->TIM_Prescaler | TIM_TimeBaseInitStruct->TIM_CounterMode |
000006  888c              LDRH     r4,[r1,#4]
000008  4013              ANDS     r3,r3,r2              ;128
00000a  880a              LDRH     r2,[r1,#0]
00000c  88cd              LDRH     r5,[r1,#6]
00000e  4322              ORRS     r2,r2,r4
000010  884c              LDRH     r4,[r1,#2]
000012  016d              LSLS     r5,r5,#5
000014  432c              ORRS     r4,r4,r5
000016  4322              ORRS     r2,r2,r4
000018  431a              ORRS     r2,r2,r3
;;;135                                 TIM_TimeBaseInitStruct->TIM_WorkMode | ( TIM_TimeBaseInitStruct->TIM_EXENX << TIM_CON_EXENX_Pos ) );
;;;136        /* Write to TIMx TIM_CON */
;;;137        TIMx->TIM_CON = tmpreg;
00001a  6002              STR      r2,[r0,#0]
;;;138        /* Write to TIMx TIM_CYCLE */
;;;139        TIMx->TIM_CNT = TIMx->TIM_RLD = TIM_TimeBaseInitStruct->TIM_Preload;
00001c  8909              LDRH     r1,[r1,#8]
00001e  6081              STR      r1,[r0,#8]
000020  6041              STR      r1,[r0,#4]
;;;140    
;;;141    }
000022  bd30              POP      {r4,r5,pc}
;;;142    
                          ENDP

                  |L24.36|
                          DCD      0xfffff89d

                          AREA ||i.TIM_TimeBaseStructInit||, CODE, READONLY, ALIGN=1

                  TIM_TimeBaseStructInit PROC
;;;147      */
;;;148    void TIM_TimeBaseStructInit ( TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct )
000000  2100              MOVS     r1,#0
;;;149    {
;;;150        /* Set the default configuration */
;;;151        TIM_TimeBaseInitStruct->TIM_Prescaler = TIM_PRESCALER_1;
000002  8001              STRH     r1,[r0,#0]
;;;152        TIM_TimeBaseInitStruct->TIM_WorkMode = TIM_WorkMode_Timer;
000004  8041              STRH     r1,[r0,#2]
;;;153        TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
000006  8081              STRH     r1,[r0,#4]
;;;154        TIM_TimeBaseInitStruct->TIM_Preload = 0x0000;
000008  8101              STRH     r1,[r0,#8]
;;;155        TIM_TimeBaseInitStruct->TIM_EXENX = TIM_EXENX_Disable;
00000a  80c1              STRH     r1,[r0,#6]
;;;156    }
00000c  4770              BX       lr
;;;157    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\FWLib\\SC32F1XXX_Lib\\src\\sc32f1xxx_tim.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_sc32f1xxx_tim_c_c458916b____REV16|
#line 463 "..\\CMSIS\\cmsis_armcc.h"
|__asm___15_sc32f1xxx_tim_c_c458916b____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_sc32f1xxx_tim_c_c458916b____REVSH|
#line 478
|__asm___15_sc32f1xxx_tim_c_c458916b____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
